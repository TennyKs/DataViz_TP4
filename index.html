<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="matrixManagement.js"></script>
    <title>TP4</title>
</head>
<body>
<h1>DataViz TP4</h1>
<label for="sort-select">Choisir un critère de tri : </label>
<select name="sorts" id="sort-select">
    <option selected="selected" value="appearances">Ordre d'apparence des personnages</option>
    <option value="influences">Influence des personnages</option>
    <option value="zones">Zones de présence partagées</option>
</select>
<br/>
<br/>

<div id="matrice"></div>
<script>
    // Definition de la taille du svg
    const margin = {top: 30, right: 30, bottom: 20, left: 50},
        width = 960,
        height = 960;

    // ajout du svg à une 'div id="matrice"' déjà créee dans la page html
    var svg = d3
        .select("#matrice")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    function d3Process() {
        d3.json("got_social_graph.json").then(function (json) {
            const nodes = json.nodes;
            const links = json.links;
            const adjancencymatrix = createAdjacencyMatrix(nodes, links, undefined, true);

            const rWidth = Math.floor(width / nodes.length),
                rHeight = Math.floor(height / nodes.length);


            var scale = d3
                .scaleQuantize()
                .range(d3.schemeBlues[9])
                .domain([0, d3.max(links, d => d.weight)]);
            var zoneScale = d3.scaleOrdinal(d3.schemeCategory10);
            const maxWeight = d3.max(links, d => d.weight);

            matrixViz = svg.selectAll("rect")
                .data(adjancencymatrix)
                .join("rect")
                .attr("width", rWidth)
                .attr("height", rHeight)
                .attr("x", function (d) {
                    return d.x * rWidth;
                })
                .attr("y", function (d) {
                    return d.y * rHeight;
                })
                .style("stroke", "black")
                .style("stroke-width", "0px")
                .style("fill", function (d) {
                    if (d.zone_s === d.zone_t)
                        return zoneScale(d.zone_s)
                    return "#eee";
                })
                .style("opacity", d => (d.weight * 10) / maxWeight);

            var positionsPersonnages = d3.range(nodes.length);
            var echellexy = d3.scaleBand()
                .range([0, width])
                .domain(positionsPersonnages)
                .paddingInner(0.1)
                .align(0)
                .round(true);


            var labels = d3.select("svg")
                .append("g")
                .attr("transform", "translate(60, 60)")
                .style("font-size", "8px")
                .style("font-family", "sans-serif");

            const fx = 8;
            var columns = labels
                .append("g")
                .selectAll()
                .data(nodes)
                .join("text")
                .text((d) => d.character)
                .attr("dy", d => echellexy(d.id) - (60 - fx) + margin.left)
                .attr("dx", 60 - (margin.top) + fx / 2)
                .attr("transform", "rotate(-90)"); // on tourne tout l'axe de 90°


            var rows = labels
                .append("g")
                .selectAll()
                .data(nodes)
                .join("text")
                .text((d) => d.character)
                .attr("text-anchor", "end")
                .attr("dx", -60 + (margin.left) - fx / 2)
                .attr("dy", d => echellexy(d.id) - (60 - fx) + margin.top)


            d3.select("#sort-select").on("input", function () {
                const x = document.getElementById("sort-select").value;
                switch (x) {
                    case "zones":
                        nodes.sort((a, b) => a.zone - b.zone)
                        break;
                    case "influences":
                        nodes.sort((a, b) => b.influence - a.influence)
                        break;
                    default:
                    case "appearances":
                        nodes.sort((a, b) => a.id - b.id)
                        break;

                }
                var newPositions = []
                nodes.forEach(i => newPositions.push(i.id));
                echellexy.domain(newPositions);
                rows
                    .transition()
                    .delay(0)
                    .duration(2000)
                    .attr("dy", d => echellexy(d.id) - (60 - fx) + margin.top)

                columns
                    .transition()
                    .delay(0)
                    .duration(2000)
                    .attr("dy", d => echellexy(d.id) - (60 - fx) + margin.left)

                svg.selectAll("rect")
                    .transition()
                    .delay(0)
                    .duration(2000)
                    .attr("x", d => echellexy(d.x))
                    .attr("y", d => echellexy(d.y));
            });


        });
    }

    d3Process();

</script>
</body>
</html>